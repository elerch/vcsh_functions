# Dynamically load virtualenvwrapper functions to reduce shell startup
# time.
#
# Copyright 2012 Aron Griffis <aron@arongriffis.com>
# Released under the GNU GPL v3
####################################################################### 

# Python virtualenvwrapper loads really slowly, so load it on demand.
if [[ ( -n "$BASH_VERSION" && "$(type -t workon)" != function ) || \
   ( -n "$ZSH_VERSION" && "$(type -w workon)" != "workon: function" ) ]]; then
  virtualenv_funcs=( workon deactivate mkvirtualenv )

  load_virtualenv() {
    # If these already exist, then virtualenvwrapper won't override them.
    unset -f "${virtualenv_funcs[@]}"

    # virtualenvwrapper doesn't load if PYTHONPATH is set, because the
    # virtualenv python doesn't have the right modules.
    declare _pp="$PYTHONPATH"
    unset PYTHONPATH

    # Attempt to load virtualenvwrapper from its many possible sources...
    _try_source() { [ -f "$1" ] || return; source "$1"; return 0; }
    _try_source /usr/local/bin/virtualenvwrapper.sh || \
    _try_source /etc/bash_completion.d/virtualenvwrapper || \
    _try_source /usr/bin/virtualenvwrapper.sh 
    declare status=$?
    unset -f _try_source

    # Restore PYTHONPATH
    [[ -n $_pp ]] && export PYTHONPATH="$_pp"

    # Did loading work?
    if [[ $status != 0 || "$(type -t "$1")" != function ]]; then
      echo "Error loading virtualenvwrapper, sorry" >&2
      return $status
    fi

    # Chain-load the appropriate function
    "$@"
  }

  for v in "${virtualenv_funcs[@]}"; do
    eval "$v() { load_virtualenv $v \"\$@\"; }"
  done
fi

create_dotfile_repo() {
  if [ $# != 1 ]; then
    echo "Usage: create-dotfile-repo dotfile"
    return 1
  fi
  nodot=$(echo "$1"|cut -c 2-)
  github_out="$(create-repo-github vcsh_"$nodot")"
  ssh_url="$(echo "$github_out" | fgrep ssh_url | cut -f 2- -d : |cut -f 2 -d \")"
  clone_url=$(echo "$github_out" | fgrep clone_url | cut -f 2- -d : |cut -f 2 -d \")
  vcsh clone "$ssh_url" "$nodot"
  vcsh "$nodot" add -f "$1"

  # Add .gitignore. See http://www.martin-burger.net/blog/unix-shell/manage-dotfiles-quickly-and-effortlessly/
  vcsh write-gitignore "$nodot"
  vcsh "$nodot" add -f ".gitignore.d/$nodot"
  vcsh write-gitignore "$nodot"
  vcsh "$nodot" add .gitignore.d/"$nodot"

  vcsh "$nodot" commit -m 'initial commit'
  vcsh "$nodot" push

  if [ -d ~/.config/mr ]; then
    echo "[\$HOME/.config/vcsh/repo.d/$nodot.git]
checkout = vcsh clone $clone_url $nodot
" > ~/.config/mr/available.d/"$nodot.vcsh"
    pushd ~/.config/mr/config.d
    ln -s ../available.d/"$nodot.vcsh"
    popd
    vcsh mr add -f "${HOME}/.config/mr/available.d/$nodot.vcsh"
    vcsh mr add -f "${HOME}/.config/mr/config.d/$nodot.vcsh"
    vcsh mr commit -m "add $nodot to configuration"
  fi
  echo "vcsh push to push all changes"
}

create_repo_github() {
  if [ $# != 1 ]; then
    echo "Usage: create-repo-github reponame"
    return 1
  fi
  if [ ! -f ~/.private/github-user ]; then
    echo "$HOME/.private/github-user not found"
    return 1
  fi
  if [ ! -f "$HOME/.private/github-tok" ]; then
    echo "$HOME/.private/github-tok not found"
    return 1
  fi

  curl -s -u "$(cat ~/.private/github-user):$(cat ~/.private/github-tok)" https://api.github.com/user/repos -d "{\"name\":\"$1\"}"
}

create_repo_bitbucket_private() {
  if [ $# != 1 ]; then
    echo "Usage: create-repo.private/bitbucket reponame"
    return 1
  fi
  if [ ! -f ~/.private/bitbucket-user ]; then
    echo "$HOME/.private/bitbucket-user not found"
    return 1
  fi
  if [ ! -f ~/.private/bitbucket-pass ]; then
    echo "$HOME/.private/bitbucket-pass not found"
    return 1
  fi
  user=$(cat ~/.private/bitbucket-user)
  curl -X POST -v -u "$user:$(cat ~/.private/bitbucket-pass)" -H "Content-Type: application/json" \
    "https://api.bitbucket.org/2.0/repositories/$user/$1"           \
  -d "{                                     \
      \"owner\": \"$user\",                 \
      \"repo_slug\": \"$1\",                 \
      \"is_private\": \"true\",             \
      \"fork_policy\": \"no_public_forks\", \
      \"has_issues\": \"true\"              \
      }"
}

aws_accountnumber() {
  aws sts get-caller-identity --output text --query 'Account'
}

all_colors() {
  for code in $(seq -w 0 255); do for attr in 0 1; do printf "%s-%03s %bTest%b\n" "${attr}" "${code}" "\e[${attr};38;05;${code}m" "\e[m"; done; done | column -c $((COLUMNS*2))
}

gen_password() {
  LC_ALL=C tr -dc 'A-Za-z0-9!"#$%&'\''()*+,-./:;<=>?@[\]^_`{|}~' </dev/urandom | head -c "${1:-20}" ; echo
}

fix_iterm2_italics() {
  # Source: http://www.eddieantonio.ca/blog/2015/04/16/iterm-italics/
  infocmp xterm-256color > /tmp/xterm-256color.terminfo
  printf '\tsitm=\\E[3m, ritm=\\E[23m,\n' >> /tmp/xterm-256color.terminfo
  tic /tmp/xterm-256color.terminfo
}

aws() {
  # Allows use of aws-vault as if we were just executing aws
  #
  # This would be necessary if we are running as a shell script
  # (note the cut ... -f 3 vs -f 2 in actual code below)
  # shadowedcommand=$(for cmd in $(whereis -b aws |cut -d ' ' -f 3-); do \
  #                   [ "aws" = "$(basename "$cmd")" ] && echo "$cmd" && break; done)
  # Since we are a function, we can just take the top of the list:
  shadowedcommand=$(for cmd in $(whereis -b aws |cut -d ' ' -f 2-); do \
    [ "aws" = "$(basename "$cmd")" ] && echo "$cmd" && break; done)
  if [ -z "${AWS_VAULT}" ]; then
    if command_exists aws-vault; then
      aws-vault exec "${AWS_DEFAULT_PROFILE:-default}" -- "${shadowedcommand}" "$@"
    else
      "${shadowedcommand}" "$@"
    fi
  else
    "${shadowedcommand}" "$@"
  fi
}

########################################################################
# Software install functions
########################################################################
function install-go() {
  local arch="linux-amd64"
  # YOLO: We'll parse the HTML of the download page
  local url="$(curl -s https://golang.org/dl/ |grep 'class="download' |grep linux-amd64 |head -n1 |cut -d\" -f4)"
  mkdir -p "$HOME"/.local
  curl -s "$url" |tar -C "$HOME"/.local -xz
}

function install-aws-vault() {
  local output=aws-vault

  if $(command_exists go); then
    go get github.com/99designs/aws-vault
  else
    # Go get is handy, but we don't actually need 120MB of stuff for the utility
    local url=$(curl -s https://api.github.com/repos/99designs/aws-vault/releases \
                |jq -r '.[0].assets[].browser_download_url' \
                |grep linux-amd64)
    output_bin="$HOME/.local/bin/$output"
    curl -sL "$url" > $output_bin
    chmod 755 $output_bin
    hash $output
  fi
}
