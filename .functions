# Dynamically load virtualenvwrapper functions to reduce shell startup
# time.
#
# Copyright 2012 Aron Griffis <aron@arongriffis.com>
# Released under the GNU GPL v3
####################################################################### 

# Python virtualenvwrapper loads really slowly, so load it on demand.
if [[ ( -n "$BASH_VERSION" && "$(type -t workon)" != function ) || \
   ( -n "$ZSH_VERSION" && "$(type -w workon)" != "workon: function" ) ]]; then
  virtualenv_funcs=( workon deactivate mkvirtualenv )

  load_virtualenv() {
    # If these already exist, then virtualenvwrapper won't override them.
    unset -f "${virtualenv_funcs[@]}"

    # virtualenvwrapper doesn't load if PYTHONPATH is set, because the
    # virtualenv python doesn't have the right modules.
    declare _pp="$PYTHONPATH"
    unset PYTHONPATH

    # Attempt to load virtualenvwrapper from its many possible sources...
    _try_source() { [ -f "$1" ] || return; source "$1"; return 0; }
    _try_source /usr/local/bin/virtualenvwrapper.sh || \
    _try_source /etc/bash_completion.d/virtualenvwrapper || \
    _try_source /usr/bin/virtualenvwrapper.sh 
    declare status=$?
    unset -f _try_source

    # Restore PYTHONPATH
    [[ -n $_pp ]] && export PYTHONPATH="$_pp"

    # Did loading work?
    if [[ $status != 0 || "$(type -t "$1")" != function ]]; then
      echo "Error loading virtualenvwrapper, sorry" >&2
      return $status
    fi

    # Chain-load the appropriate function
    "$@"
  }

  for v in "${virtualenv_funcs[@]}"; do
    eval "$v() { load_virtualenv $v \"\$@\"; }"
  done
fi

create_dotfile_repo() {
  if [ $# != 1 ]; then
    echo "Usage: create-dotfile-repo dotfile"
    return 1
  fi
  nodot=$(echo "$1"|cut -c 2-)
  github_out="$(create-repo-github vcsh_"$nodot")"
  ssh_url="$(echo "$github_out" | fgrep ssh_url | cut -f 2- -d : |cut -f 2 -d \")"
  clone_url=$(echo "$github_out" | fgrep clone_url | cut -f 2- -d : |cut -f 2 -d \")
  vcsh clone "$ssh_url" "$nodot"
  vcsh "$nodot" add -f "$1"

  # Add .gitignore. See http://www.martin-burger.net/blog/unix-shell/manage-dotfiles-quickly-and-effortlessly/
  vcsh write-gitignore "$nodot"
  vcsh "$nodot" add -f ".gitignore.d/$nodot"
  vcsh write-gitignore "$nodot"
  vcsh "$nodot" add .gitignore.d/"$nodot"

  vcsh "$nodot" commit -m 'initial commit'
  vcsh "$nodot" push

  if [ -d ~/.config/mr ]; then
    echo "[\$HOME/.config/vcsh/repo.d/$nodot.git]
checkout = vcsh clone $clone_url $nodot
" > ~/.config/mr/available.d/"$nodot.vcsh"
    pushd ~/.config/mr/config.d
    ln -s ../available.d/"$nodot.vcsh"
    popd
    vcsh mr add -f "${HOME}/.config/mr/available.d/$nodot.vcsh"
    vcsh mr add -f "${HOME}/.config/mr/config.d/$nodot.vcsh"
    vcsh mr commit -m "add $nodot to configuration"
  fi
  echo "vcsh push to push all changes"
}

create_repo_github() {
  if [ $# != 1 ]; then
    echo "Usage: create-repo-github reponame"
    return 1
  fi
  if [ ! -f ~/.private/github-user ]; then
    echo "$HOME/.private/github-user not found"
    return 1
  fi
  if [ ! -f "$HOME/.private/github-tok" ]; then
    echo "$HOME/.private/github-tok not found"
    return 1
  fi

  curl -s -u "$(cat ~/.private/github-user):$(cat ~/.private/github-tok)" https://api.github.com/user/repos -d "{\"name\":\"$1\"}"
}

create_repo_bitbucket_private() {
  if [ $# != 1 ]; then
    echo "Usage: create-repo.private/bitbucket reponame"
    return 1
  fi
  if [ ! -f ~/.private/bitbucket-user ]; then
    echo "$HOME/.private/bitbucket-user not found"
    return 1
  fi
  if [ ! -f ~/.private/bitbucket-pass ]; then
    echo "$HOME/.private/bitbucket-pass not found"
    return 1
  fi
  user=$(cat ~/.private/bitbucket-user)
  curl -X POST -v -u "$user:$(cat ~/.private/bitbucket-pass)" -H "Content-Type: application/json" \
    "https://api.bitbucket.org/2.0/repositories/$user/$1"           \
  -d "{                                     \
      \"owner\": \"$user\",                 \
      \"repo_slug\": \"$1\",                 \
      \"is_private\": \"true\",             \
      \"fork_policy\": \"no_public_forks\", \
      \"has_issues\": \"true\"              \
      }"
}

aws_accountnumber() {
  aws sts get-caller-identity --output text --query 'Account'
}

all_colors() {
  for code in $(seq -w 0 255); do for attr in 0 1; do printf "%s-%03s %bTest%b\n" "${attr}" "${code}" "\e[${attr};38;05;${code}m" "\e[m"; done; done | column -c $((COLUMNS*2))
}

gen_password() {
  LC_ALL=C tr -dc 'A-Za-z0-9!"#$%&'\''()*+,-./:;<=>?@[\]^_`{|}~' </dev/urandom | head -c "${1:-20}" ; echo
}

fix_iterm2_italics() {
  # Source: http://www.eddieantonio.ca/blog/2015/04/16/iterm-italics/
  infocmp xterm-256color > /tmp/xterm-256color.terminfo
  printf '\tsitm=\\E[3m, ritm=\\E[23m,\n' >> /tmp/xterm-256color.terminfo
  tic /tmp/xterm-256color.terminfo
}

aws() {
  # Allows use of aws-vault as if we were just executing aws
  #
  # This would be necessary if we are running as a shell script
  # (note the cut ... -f 3 vs -f 2 in actual code below)
  # shadowedcommand=$(for cmd in $(whereis -b aws |cut -d ' ' -f 3-); do \
  #                   [ "aws" = "$(basename "$cmd")" ] && echo "$cmd" && break; done)
  # Since we are a function, we can just take the top of the list:
  shadowedcommand=$(for cmd in $(whereis -b aws |cut -d ' ' -f 2-); do \
    [ "aws" = "$(basename "$cmd")" ] && echo "$cmd" && break; done)
  if [ -z "${AWS_VAULT}" ]; then
    if command_exists aws-vault; then
      aws-vault exec "${AWS_DEFAULT_PROFILE:-default}" -- "${shadowedcommand}" "$@"
    else
      "${shadowedcommand}" "$@"
    fi
  else
    "${shadowedcommand}" "$@"
  fi
}

########################################################################
# Software install functions
########################################################################
install_go() {
  local arch="linux-amd64"
  # YOLO: We'll parse the HTML of the download page
  local url
  url="$(curl -s https://golang.org/dl/ |grep 'class="download' |grep "$arch" |head -n1 |cut -d\" -f4)"
  mkdir -p "$HOME"/.local
  curl -s "$url" |tar -C "$HOME"/.local -xz
}

install_aws_vault() {
  local output=aws-vault

  if command_exists go; then
    go get github.com/99designs/aws-vault
  else
    # Go get is handy, but we don't actually need 120MB of stuff for the utility
    local url
    url=$(curl -s https://api.github.com/repos/99designs/aws-vault/releases \
          |jq -r '.[0].assets[].browser_download_url' \
          |grep linux-amd64)
    output_bin="$HOME/.local/bin/$output"
    curl -sL "$url" > "$output_bin"
    chmod 755 "$output_bin"
    hash $output
  fi
}

########################################################################
# Docker containers
########################################################################
zoom() {
  # Give display rights to the user if not already enabled
  xhost | grep -q "SI:localuser:${USER}" || \
    xhost +SI:localuser:"${USER}"
    
  # --device /dev/snd \

  docker run  \
    -v /tmp/.X11-unix:/tmp/.X11-unix \
    -e DISPLAY="unix$DISPLAY" \
    -v /run/dbus/:/run/dbus/ \
    -v /dev/shm:/dev/shm \
    --device /dev/dri \
    --device /dev/video0 \
    --group-add "$(getent group audio | cut -d: -f3)" \
    -e PULSE_SERVER="unix:${XDG_RUNTIME_DIR}/pulse/native" \
    -v "${XDG_RUNTIME_DIR}/pulse/native:${XDG_RUNTIME_DIR}/pulse/native" \
    --group-add video \
    -u "$(id -u "$USER"):$(id -g "$USER")" \
    --name zoom \
    -d
    --rm \
    jess/zoom-us
}

create_secondary_pa_for_root() {
  # This creates a socket in a 700 directory for pulseaudio. The socket itself
  # has anonymous access, but as it's for audio the threat model is at least
  # somewhat constrained.
  if [ -z "$PULSE_SERVER_SECONDARY_SOCKET" ]; then
    local tdir
    tdir=$(mktemp -d "$XDG_RUNTIME_DIR/pa.XXXXXXX")
    pacmd load-module module-native-protocol-unix auth-anonymous=1 socket="$tdir/pa.socket"
    export PULSE_SERVER_SECONDARY_SOCKET="$tdir/pa.socket"
  fi
  echo "export PULSE_SERVER_SECONDARY_SOCKET=$PULSE_SERVER_SECONDARY_SOCKET"

}
# We only have a couple config files exposed to host, so we will run this
# as root in the container
workspaces() {
  # Give display rights to the ROOT user if not already enabled
  xhost | grep -q "SI:localuser:root" || \
    xhost +SI:localuser:"root"

  local image
  image=${1:-elerch/workspaces:latest}
  local appdatalocal
  appdatalocal="$HOME/.docker/Amazon WorkSpaces"
  mkdir -p "$appdatalocal"
  local appdatacontainer
  appdatacontainer="/root/.wine/drive_c/users/root/Local Settings/Application Data/Amazon Web Services/Amazon WorkSpaces"

  local xopts
  xopts=(-v /tmp/.X11-unix:/tmp/.X11-unix \
               -e DISPLAY=unix${DISPLAY} \
               --device /dev/dri)
  eval "$(create_secondary_pa_for_root)"
  local soundopts=(-e PULSE_SERVER="unix:$PULSE_SERVER_SECONDARY_SOCKET" \
    -v "$PULSE_SERVER_SECONDARY_SOCKET:$PULSE_SERVER_SECONDARY_SOCKET" \
    )
  # local soundopts=(-e PULSE_SERVER="unix:${XDG_RUNTIME_DIR}/pulse/native" \
  # -v "${XDG_RUNTIME_DIR}/pulse/native:${XDG_RUNTIME_DIR}/pulse/native" \
  #   --group-add $(getent group audio | cut -d: -f3) )
  #docker run -d --rm $xopts $soundopts \
  docker run -d --rm "${xopts[@]}" "${soundopts[@]}" \
    -e TZ="${TZ:-$(cat /etc/timezone)}" \
    -v "$appdatalocal/registrationCache.json:$appdatacontainer/registrationCache.json" \
    -v "$appdatalocal/profiles:$appdatacontainer/profiles" \
    "$image"
}
