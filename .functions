# Dynamically load virtualenvwrapper functions to reduce shell startup
# time.
#
# Copyright 2012 Aron Griffis <aron@arongriffis.com>
# Released under the GNU GPL v3
####################################################################### 

# Python virtualenvwrapper loads really slowly, so load it on demand.
if [[ ( -n "$BASH_VERSION" && "$(type -t workon)" != function ) || \
   ( -n "$ZSH_VERSION" && "$(type -w workon)" != "workon: function" ) ]]; then
  virtualenv_funcs=( workon deactivate mkvirtualenv )

  load_virtualenv() {
    # If these already exist, then virtualenvwrapper won't override them.
    unset -f "${virtualenv_funcs[@]}"

    # virtualenvwrapper doesn't load if PYTHONPATH is set, because the
    # virtualenv python doesn't have the right modules.
    declare _pp="$PYTHONPATH"
    unset PYTHONPATH

    # Attempt to load virtualenvwrapper from its many possible sources...
    _try_source() { [ -f "$1" ] || return; source "$1"; return 0; }
    _try_source /usr/local/bin/virtualenvwrapper.sh || \
    _try_source /etc/bash_completion.d/virtualenvwrapper || \
    _try_source /usr/bin/virtualenvwrapper.sh 
    declare status=$?
    unset -f _try_source

    # Restore PYTHONPATH
    [[ -n $_pp ]] && export PYTHONPATH="$_pp"

    # Did loading work?
    if [[ $status != 0 || "$(type -t "$1")" != function ]]; then
      echo "Error loading virtualenvwrapper, sorry" >&2
      return $status
    fi

    # Chain-load the appropriate function
    "$@"
  }

  for v in "${virtualenv_funcs[@]}"; do
    eval "$v() { load_virtualenv $v \"\$@\"; }"
  done
fi

create_dotfile_repo() {
  if [ $# != 1 ]; then
    echo "Usage: create-dotfile-repo dotfile"
    return 1
  fi
  nodot=$(echo "$1"|cut -c 2-)
  github_out="$(create-repo-github vcsh_"$nodot")"
  ssh_url="$(echo "$github_out" | fgrep ssh_url | cut -f 2- -d : |cut -f 2 -d \")"
  clone_url=$(echo "$github_out" | fgrep clone_url | cut -f 2- -d : |cut -f 2 -d \")
  vcsh clone "$ssh_url" "$nodot"
  vcsh "$nodot" add -f "$1"

  # Add .gitignore. See http://www.martin-burger.net/blog/unix-shell/manage-dotfiles-quickly-and-effortlessly/
  vcsh write-gitignore "$nodot"
  vcsh "$nodot" add -f ".gitignore.d/$nodot"
  vcsh write-gitignore "$nodot"
  vcsh "$nodot" add .gitignore.d/"$nodot"

  vcsh "$nodot" commit -m 'initial commit'
  vcsh "$nodot" push

  if [ -d ~/.config/mr ]; then
    echo "[\$HOME/.config/vcsh/repo.d/$nodot.git]
checkout = vcsh clone $clone_url $nodot
" > ~/.config/mr/available.d/"$nodot.vcsh"
    pushd ~/.config/mr/config.d
    ln -s ../available.d/"$nodot.vcsh"
    popd
    vcsh mr add -f "${HOME}/.config/mr/available.d/$nodot.vcsh"
    vcsh mr add -f "${HOME}/.config/mr/config.d/$nodot.vcsh"
    vcsh mr commit -m "add $nodot to configuration"
  fi
  echo "vcsh push to push all changes"
}

create_repo_github() {
  if [ $# != 1 ]; then
    echo "Usage: create-repo-github reponame"
    return 1
  fi
  if [ ! -f ~/.private/github-user ]; then
    echo "$HOME/.private/github-user not found"
    return 1
  fi
  if [ ! -f "$HOME/.private/github-tok" ]; then
    echo "$HOME/.private/github-tok not found"
    return 1
  fi

  curl -s -u "$(cat ~/.private/github-user):$(cat ~/.private/github-tok)" https://api.github.com/user/repos -d "{\"name\":\"$1\"}"
}

create_repo_bitbucket_private() {
  if [ $# != 1 ]; then
    echo "Usage: create-repo.private/bitbucket reponame"
    return 1
  fi
  if [ ! -f ~/.private/bitbucket-user ]; then
    echo "$HOME/.private/bitbucket-user not found"
    return 1
  fi
  if [ ! -f ~/.private/bitbucket-pass ]; then
    echo "$HOME/.private/bitbucket-pass not found"
    return 1
  fi
  user=$(cat ~/.private/bitbucket-user)
  curl -X POST -v -u "$user:$(cat ~/.private/bitbucket-pass)" -H "Content-Type: application/json" \
    "https://api.bitbucket.org/2.0/repositories/$user/$1"           \
  -d "{                                     \
      \"owner\": \"$user\",                 \
      \"repo_slug\": \"$1\",                 \
      \"is_private\": \"true\",             \
      \"fork_policy\": \"no_public_forks\", \
      \"has_issues\": \"true\"              \
      }"
}

aws_accountnumber() {
  aws sts get-caller-identity --output text --query 'Account'
}

all_colors() {
  for code in $(seq -w 0 255); do for attr in 0 1; do printf "%s-%03s %bTest%b\n" "${attr}" "${code}" "\e[${attr};38;05;${code}m" "\e[m"; done; done | column -c $((COLUMNS*2))
}

gen_password() {
  LC_ALL=C tr -dc 'A-Za-z0-9!"#$%&'\''()*+,-./:;<=>?@[\]^_`{|}~' </dev/urandom | head -c "${1:-20}" ; echo
}

fix_iterm2_italics() {
  # Source: http://www.eddieantonio.ca/blog/2015/04/16/iterm-italics/
  infocmp xterm-256color > /tmp/xterm-256color.terminfo
  printf '\tsitm=\\E[3m, ritm=\\E[23m,\n' >> /tmp/xterm-256color.terminfo
  tic /tmp/xterm-256color.terminfo
}

aws() {
  # Allows use of aws-vault as if we were just executing aws
  #
  # This would be necessary if we are running as a shell script
  # (note the cut ... -f 3 vs -f 2 in actual code below)
  # shadowedcommand=$(for cmd in $(whereis -b aws |cut -d ' ' -f 3-); do \
  #                   [ "aws" = "$(basename "$cmd")" ] && echo "$cmd" && break; done)
  # Since we are a function, we can just take the top of the list:
  shadowedcommand=$(for cmd in $(whereis -b aws |cut -d ' ' -f 2-); do \
    [ "aws" = "$(basename "$cmd")" ] && echo "$cmd" && break; done)
  if [ -z "${AWS_VAULT}" ]; then
    if command_exists aws-vault; then
      aws-vault exec "${AWS_DEFAULT_PROFILE:-default}" -- "${shadowedcommand}" "$@"
    else
      "${shadowedcommand}" "$@"
    fi
  else
    "${shadowedcommand}" "$@"
  fi
}

########################################################################
# Software install functions
########################################################################
arch() {
  local ARCH=$(uname -m)
  case $ARCH in
    armv5*) ARCH="armv5";;
    armv6*) ARCH="armv6";;
    armv7*) ARCH="armv7";;
    aarch64) ARCH="arm64";;
    x86) ARCH="386";;
    x86_64) ARCH="amd64";;
    i686) ARCH="386";;
    i386) ARCH="386";;
  esac
  echo $ARCH
}

os() {
  echo "linux" # darwin for mac
}

download() {
  if [ $# -ne 2 ]; then
    echo "usage: download <url> <location>"
    return 1
  fi
  echo Downloading "$1" to "$2"
  if command_exists curl; then
    curl -SsL "$1" -o "$2"
  elif command_exists wget; then
    wget -q -O "$2" "$1"
  else
    echo install wget or curl to use this
    return 2
  fi
}

checksum() {
  if [ $# -ne 3 ]; then
    echo "usage: checksum bits <file> <sum file>"
    return 1
  fi
  local sum=$(openssl sha1 "-sha${1}" "${2}" | awk '{print $2}')
  if [ "$sum" != "$(cat "${3}")" ]; then
    echo "SHA sum of ${2} does not match the sum in file ${3}" >&2
    return 2
  fi
  return 0
}

install_rust() {
  curl https://sh.rustup.rs -sSf | sh -s -- -y --no-modify-path
}

install_musl_dev() {
  pushd $HOME
  git clone git://git.musl-libc.org/musl
  cd musl
  ./configure --prefix="$HOME/.local/musl" --exec-prefix="$HOME/.local/"
  make && make install
  cd ..
  rm -rf musl
  popd
}

install_helm() {
  local release_tag=$(curl -s https://api.github.com/repos/helm/helm/releases |jq -r '[.[] | select(.prerelease == false)][0].tag_name')
  local url="https://storage.googleapis.com/kubernetes-helm/helm-$release_tag-$(os)-$(arch).tar.gz"
  local sum_url="https://storage.googleapis.com/kubernetes-helm/helm-$release_tag-$(os)-$(arch).tar.gz.sha256"
  local tmp_root="$(mktemp -dt install-help-XXXXXX)"
  download "$url" "${tmp_root}/helm.tgz"
  download "$sum_url" "${tmp_root}/helm.tgz.sha256"
  checksum 256 "${tmp_root}/helm.tgz" "${tmp_root}/helm.tgz.sha256" || return 1
  tar xf "${tmp_root}/helm.tgz" -C "${tmp_root}"
  local helm="${tmp_root}/$(os)-$(arch)/helm"
  local tiller="${tmp_root}/$(os)-$(arch)/tiller"
  mkdir -p "${HOME}/.local/bin"
  mv "$helm" "$tiller" "${HOME}/.local/bin"
  rm -rf "${tmp_root}"
}

install_go() {
  local arch="$(os)-$(arch)"
  # YOLO: We'll parse the HTML of the download page
  local url
  url="$(curl -s https://golang.org/dl/ |grep 'class="download' |grep "$arch" |head -n1 |cut -d\" -f4)"
  mkdir -p "$HOME"/.local
  curl -s "$url" |tar -C "$HOME"/.local -xz
}

install_kubectl() {
  local url="https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/$(os)/$(arch)/kubectl"
  mkdir -p "$HOME"/.local/bin
  download "$url" "$HOME"/.local/bin/kubectl
  chmod 755 "$HOME"/.local/bin/kubectl
}

install_kubectl_aws_iam_auth() {
  local url=$(curl -s https://api.github.com/repos/kubernetes-sigs/aws-iam-authenticator/releases/latest | grep 'browser_' | cut -d\" -f4 |grep $(os)_$(arch))
  download "$url" "$HOME"/.local/bin/aws-iam-authenticator
  chmod 755 "$HOME"/.local/bin/aws-iam-authenticator
}

install_aws_vault() {
  local output=aws-vault

  if command_exists go; then
    go get github.com/99designs/aws-vault
  else
    # Go get is handy, but we don't actually need 120MB of stuff for the utility
    local url
    url=$(curl -s https://api.github.com/repos/99designs/aws-vault/releases \
          |jq -r '.[0].assets[].browser_download_url' \
          |grep $(os)-$(arch))
    output_bin="$HOME/.local/bin/$output"
    download "$url" "$output_bin"
    chmod 755 "$output_bin"
    hash $output
  fi
}

########################################################################
# Docker containers
########################################################################
generic_x_enabled_run_as_root() {
  # Give display rights to the user if not already enabled
  xhost | grep -q "SI:localuser:root" || \
    xhost +SI:localuser:"root"

  # --device /dev/snd \

  docker run  \
    -v /tmp/.X11-unix:/tmp/.X11-unix \
    -e DISPLAY="unix$DISPLAY" \
    -v /run/dbus/:/run/dbus/ \
    -v /dev/shm:/dev/shm \
    --device /dev/dri \
    --device /dev/video0 \
    --group-add "$(getent group audio | cut -d: -f3)" \
    -e PULSE_SERVER="unix:${XDG_RUNTIME_DIR}/pulse/native" \
    -v "${XDG_RUNTIME_DIR}/pulse/native:${XDG_RUNTIME_DIR}/pulse/native" \
    --group-add video \
    -it \
    --rm \
    "${1:-"debian:sid-slim"}" /bin/sh
}

zoom() {
  # Give display rights to the user if not already enabled
  xhost | grep -q "SI:localuser:${USER}" || \
    xhost +SI:localuser:"${USER}"

  # --device /dev/snd \

  docker run  \
    -v /tmp/.X11-unix:/tmp/.X11-unix \
    -e DISPLAY="unix$DISPLAY" \
    -v /run/dbus/:/run/dbus/ \
    -v /dev/shm:/dev/shm \
    --device /dev/dri \
    --device /dev/video0 \
    --group-add "$(getent group audio | cut -d: -f3)" \
    -e PULSE_SERVER="unix:${XDG_RUNTIME_DIR}/pulse/native" \
    -v "${XDG_RUNTIME_DIR}/pulse/native:${XDG_RUNTIME_DIR}/pulse/native" \
    --group-add video \
    -u "$(id -u "$USER"):$(id -g "$USER")" \
    --name zoom \
    -d \
    --rm \
    jess/zoom-us
}

create_secondary_pa_for_root() {
  # This creates a socket in a 700 directory for pulseaudio. The socket itself
  # has anonymous access, but as it's for audio the threat model is at least
  # somewhat constrained.
  if [ -z "$PULSE_SERVER_SECONDARY_SOCKET" ]; then
    local tdir
    tdir=$(mktemp -d "$XDG_RUNTIME_DIR/pa.XXXXXXX")
    pacmd load-module module-native-protocol-unix auth-anonymous=1 socket="$tdir/pa.socket"
    export PULSE_SERVER_SECONDARY_SOCKET="$tdir/pa.socket"
  fi
  echo "export PULSE_SERVER_SECONDARY_SOCKET=$PULSE_SERVER_SECONDARY_SOCKET"

}
# We only have a couple config files exposed to host, so we will run this
# as root in the container
workspaces() {
  # Give display rights to the ROOT user if not already enabled
  xhost | grep -q "SI:localuser:root" || \
    xhost +SI:localuser:"root"

  local image
  image=${1:-elerch/workspaces:latest}
  local appdatalocal
  appdatalocal="$HOME/.docker/Amazon WorkSpaces"
  mkdir -p "$appdatalocal"
  local appdatacontainer
  appdatacontainer="/root/.wine/drive_c/users/root/Local Settings/Application Data/Amazon Web Services/Amazon WorkSpaces"

  local xopts
  xopts=(-v /tmp/.X11-unix:/tmp/.X11-unix \
               -e DISPLAY=unix${DISPLAY} \
               --device /dev/dri)
  eval "$(create_secondary_pa_for_root)"
  local soundopts=(-e PULSE_SERVER="unix:$PULSE_SERVER_SECONDARY_SOCKET" \
    -v "$PULSE_SERVER_SECONDARY_SOCKET:$PULSE_SERVER_SECONDARY_SOCKET" \
    )
  # local soundopts=(-e PULSE_SERVER="unix:${XDG_RUNTIME_DIR}/pulse/native" \
  # -v "${XDG_RUNTIME_DIR}/pulse/native:${XDG_RUNTIME_DIR}/pulse/native" \
  #   --group-add $(getent group audio | cut -d: -f3) )
  #docker run -d --rm $xopts $soundopts \
  #
  # Trying --net host for clipboard stability
  docker run -d "${xopts[@]}" "${soundopts[@]}" \
    --net host \
    -e TZ="${TZ:-$(cat /etc/timezone)}" \
    -v "$appdatalocal/registrationCache.json:$appdatacontainer/registrationCache.json" \
    -v "$appdatalocal/profiles:$appdatacontainer/profiles" \
    "$image"
}

libreoffice() {
  # Give display rights to the user if not already enabled
  xhost | grep -q "SI:localuser:${USER}" || \
    xhost +SI:localuser:"${USER}"

  docs="${1:-$HOME/}"

  # Give display rights to the user if not already enabled
  xhost | grep -q "SI:localuser:${USER}" || \
    xhost +SI:localuser:"${USER}"

   docker run --rm -d \
          -v /etc/localtime:/etc/localtime:ro \
          -v /etc/passwd:/etc/passwd:ro \
          -v /tmp/.X11-unix:/tmp/.X11-unix \
          -e DISPLAY=unix"$DISPLAY" \
          -v "$docs":/home/user \
          -u "$(id -u "$USER")":"$(id -g "$USER")" \
          -e GDK_SCALE \
          -e GDK_DPI_SCALE \
          --name libreoffice \
          elerch/libreoffice
}

chrome() {
  # anonymous by default. Other branch is "loggedin"
  git -C "$HOME/.config/chrome" checkout -f "${1:-anonymous}" > /dev/null
  git -C "$HOME/.config/chrome" clean -df >/dev/null

  # Give display rights to the user if not already enabled
  xhost | grep -q "SI:localuser:${USER}" || \
    xhost +SI:localuser:"${USER}"

  # We're giving 2GB by default. I tried lower values, but
  # some of the normal Google properties I use suck memory
  # like a pig. I'm looking at you, Google meetings...
  docker run -it \
    --net host \
    --cpuset-cpus 2 \
    --memory "${2:-"2048mb"}" \
    -v /tmp/.X11-unix:/tmp/.X11-unix \
    -e DISPLAY=unix"$DISPLAY" \
    -v "$HOME"/Downloads:/home/chrome/Downloads \
    -v "$HOME"/.config/chrome/:/data \
    -v /run/dbus/:/run/dbus/ \
    -v /dev/shm:/dev/shm \
    --security-opt seccomp="$HOME"/chrome.json \
    --device /dev/snd \
    --device /dev/dri \
    --device /dev/video0 \
    --group-add "$(getent group audio | cut -d: -f3)" \
    -e PULSE_SERVER=unix:"${XDG_RUNTIME_DIR}"/pulse/native \
    -v "${XDG_RUNTIME_DIR}"/pulse/native:"${XDG_RUNTIME_DIR}"/pulse/native \
    --group-add video \
    -v /dev/shm:/dev/shm \
    -u "$(id -u "$USER")":"$(id -g "$USER")" \
    --name chrome \
    --rm \
    jess/chrome
}

docker-search-tags() {
  [ ${#} -ne 1 ] && echo "docker-search-tags <image>" >&2 && return 1
  i=0

  # This ends up with some jq error output at the end, but whatever - YOLO
  while [ $? == 0 ]
  do
     i=$((i+1))
     curl https://registry.hub.docker.com/v2/repositories/library/${1}/tags/?page=$i 2>/dev/null|jq -r '."results"[]["name"]'
  done
}

rdesktop () {
  xhost | grep -q "SI:localuser:${USER}" || xhost +SI:localuser:"${USER}"
  echo "Container attached to TTY. Ctrl-P + Ctrl-Q to detach"
  # would be nice to name the container after the host connection
  docker run -it -e DISPLAY=unix$DISPLAY -v /tmp/.X11-unix:/tmp/.X11-unix -v $HOME:$HOME -u $(id -u):$(id -g) jess/rdesktop -u ${USER} $*
}

my-ipv4 () {
  curl -s -4 ifconfig.co
}

authorize-security-group-ingress () {
  [ ${#} -ne 3 ] && echo "revoke-security-group-ingress <groupname> <protocol> <port>" >&2 && return 1
  echo "Revoking any previously authorized ingress for this host"
  revoke-security-group-ingress $1 $2 $3
  echo "Adding authorization for host"
  aws ec2 authorize-security-group-ingress --group-name $1 --ip-permissions \
    IpProtocol=$2,FromPort=$3,ToPort=$3,IpRanges="[{CidrIp=$(curl -s -4 ifconfig.co)/32,Description=Host:$HOST}]"
}

revoke-security-group-ingress () {
  [ ${#} -ne 3 ] && echo "revoke-security-group-ingress <groupname> <protocol> <port>" >&2 && return 1
  # looking for security group description in the format Host:$HOST
  local ip=$(aws ec2 describe-security-groups --group-name $1 | \
             jq -r ".SecurityGroups[0].IpPermissions[0].IpRanges[] | select(.Description==\"Host:$HOST\") | .CidrIp")
  [ -z "$ip" ] && echo "Ip not found for host on SG $1" && return 0
  aws ec2 revoke-security-group-ingress --group-name $1 --protocol $2 --port $3 --cidr $ip
}

install-language-servers () {
  # Javascript is a real PITA
  # using nvm, npm install -g javascript-typescript-langserver
  # Rust
  command_exists rustup && \
    echo 'installing Rust rls' && \
    rustup update && \
    rustup component add rls rust-analysis rust-src

  # Python
  command_exists pip && \
    echo 'installing python-language-server (pyls)' && \
    pip install --user python-language-server

  # Go
  command_exists go && \
    echo 'installing go-language-server' && \
    go get -u github.com/saibing/bingo
}
