# Dynamically load virtualenvwrapper functions to reduce shell startup
# time.
#
# Copyright 2012 Aron Griffis <aron@arongriffis.com>
# Released under the GNU GPL v3
####################################################################### 

# Python virtualenvwrapper loads really slowly, so load it on demand.
if ! command -V workon >/dev/null 2>&1 || command -V workon | grep -vq function; then
  virtualenv_funcs="workon deactivate mkvirtualenv"

  load_virtualenv() {
    # If these already exist, then virtualenvwrapper won't override them.
    # shellcheck disable=SC2086
    unset -f $virtualenv_funcs

    # virtualenvwrapper doesn't load if PYTHONPATH is set, because the
    # virtualenv python doesn't have the right modules.
    _pp="$PYTHONPATH"
    unset PYTHONPATH

    # Attempt to load virtualenvwrapper from its many possible sources...
    _try_source() { [ -f "$1" ] || return; . "$1"; return 0; }
    _try_source /usr/local/bin/virtualenvwrapper.sh || \
    _try_source /etc/bash_completion.d/virtualenvwrapper || \
    _try_source /usr/bin/virtualenvwrapper.sh
    status=$?
    unset -f _try_source

    # Restore PYTHONPATH
    [ -n "$_pp" ] && export PYTHONPATH="$_pp"

    # Did loading work?
    if [ $status != 0 ] || command -V "$1" | grep -vq function; then
      echo "Error loading virtualenvwrapper, sorry" >&2
      return $status
    fi

    # Chain-load the appropriate function
    "$@"
  }

  echo "virtualenv_funcs" | tr ' ' '\n' | while read -r v; do
    eval "$v() { load_virtualenv $v \"\$@\"; }"
  done
fi

create_dotfile_repo() {
  if [ $# != 1 ]; then
    echo "Usage: create-dotfile-repo dotfile"
    echo "dotfile should be the actual file name (with the . character)"
    return 1
  fi
  nodot=$(echo "$1"|cut -c 2-)
  github_out="$(create_repo_github vcsh_"$nodot")"
  rc=$?
  if [ $rc -ne 0 ]; then
    echo "Error from creation: checking to see if repo exists" >&2
    github_out=$(curl -f -s "https://api.github.com/repos/$(cat "$HOME/.private/github-user")/vcsh_${nodot}")
    rc=$?
    if [ $rc -eq 0 ]; then
      echo "WARNING: Repo exists, and this may be in a bad state" >&2
    fi
  fi
  if [ $rc -ne 0 ]; then
    echo "Could not create github repo" >&2
    return 1
  fi
  ssh_url="$(echo "$github_out" | grep -F ssh_url | cut -f 2- -d : |cut -f 2 -d \")"
  clone_url=$(echo "$github_out" | grep -F clone_url | cut -f 2- -d : |cut -f 2 -d \")
  if vcsh clone "$ssh_url" "$nodot"; then
    echo "Error cloning $ssh_url to $nodot" >&3
    return 1
  fi
  vcsh "$nodot" add -f "$1"

  # Add .gitignore. See http://www.martin-burger.net/blog/unix-shell/manage-dotfiles-quickly-and-effortlessly/
  vcsh write-gitignore "$nodot"
  vcsh "$nodot" add -f ".gitignore.d/$nodot"
  vcsh write-gitignore "$nodot"
  vcsh "$nodot" add .gitignore.d/"$nodot"

  vcsh "$nodot" commit -m 'initial commit'
  vcsh "$nodot" push

  if [ -d ~/.config/mr ]; then
    echo "[\$HOME/.config/vcsh/repo.d/$nodot.git]
checkout = vcsh clone $clone_url $nodot
" > ~/.config/mr/available.d/"$nodot.vcsh"
    ( cd ~/.config/mr/config.d && \
      ln -s ../available.d/"$nodot.vcsh" .)
    vcsh mr add -f "${HOME}/.config/mr/available.d/$nodot.vcsh"
    vcsh mr add -f "${HOME}/.config/mr/config.d/$nodot.vcsh"
    vcsh mr commit -m "add $nodot to configuration"
  fi
  echo "vcsh push to push all changes"
  unset nodot github_out ssh_url clone_url rc
}

create_repo_github() {
  if [ $# != 1 ]; then
    echo "Usage: create_repo_github reponame"
    return 1
  fi
  github_secret=$(get_secret github)
  if [ -z "${github_secret}" ]; then
    echo "secret 'github' not found. use gpgedit ~/.secrets to add a token"
  fi

  curl -f -s -u "$github_secret" https://api.github.com/user/repos -d "{\"name\":\"$1\"}"
  unset github_secret
}

aws_accountnumber() {
  aws sts get-caller-identity --output text --query 'Account'
}

all_colors() {
  for code in $(seq -w 0 255); do for attr in 0 1; do printf "%s-%03s %bTest%b\n" "${attr}" "${code}" "\e[${attr};38;05;${code}m" "\e[m"; done; done | column -c $((COLUMNS*2))
}

gen_password() {
  LC_ALL=C tr -dc 'A-Za-z0-9!"#$%&'\''()*+,-./:;<=>?@[\]^_`{|}~' </dev/urandom | head -c "${1:-20}" ; echo
}

fix_iterm2_italics() {
  # Source: http://www.eddieantonio.ca/blog/2015/04/16/iterm-italics/
  infocmp xterm-256color > /tmp/xterm-256color.terminfo
  printf '\tsitm=\\E[3m, ritm=\\E[23m,\n' >> /tmp/xterm-256color.terminfo
  tic /tmp/xterm-256color.terminfo
}

aws() {
  # Allows use of aws-vault as if we were just executing aws
  #
  # This would be necessary if we are running as a shell script
  # (note the cut ... -f 3 vs -f 2 in actual code below)
  # shadowedcommand=$(for cmd in $(whereis -b aws |cut -d ' ' -f 3-); do \
  #                   [ "aws" = "$(basename "$cmd")" ] && echo "$cmd" && break; done)
  # Since we are a function, we can just take the top of the list:
  shadowedcommand=$(for cmd in $(whereis -b aws |cut -d ' ' -f 2-); do \
    [ "aws" = "$(basename "$cmd")" ] && echo "$cmd" && break; done)
  if [ -z "${AWS_VAULT}" ]; then
    if command_exists aws-vault; then
      aws-vault exec "${AWS_DEFAULT_PROFILE:-default}" -- "${shadowedcommand}" "$@"
    else
      "${shadowedcommand}" "$@"
    fi
  else
    "${shadowedcommand}" "$@"
  fi
  unset shadowedcommand
}

########################################################################
# Software install functions
########################################################################
arch() {
  arch=$(uname -m)
  case $arch in
    armv5*) arch="armv5";;
    armv6*) arch="armv6";;
    armv7*) arch="armv7";;
    aarch64) arch="arm64";;
    x86) arch="386";;
    x86_64) arch="amd64";;
    i686) arch="386";;
    i386) arch="386";;
  esac
  [ "$1" = "x86var" ] && [ $arch = "amd64" ] && arch="x86_64"
  echo $arch
  unset arch
}

os() {
  uname -s | tr '[:upper:]' '[:lower:]' # "linux"/"darwin" (mac)
}

download() {
  if [ $# -ne 2 ]; then
    echo "usage: download <url> <location>"
    return 1
  fi
  echo Downloading "$1" to "$2"
  if command_exists curl; then
    curl -SsL "$1" -o "$2"
  elif command_exists wget; then
    wget -q -O "$2" "$1"
  else
    echo install wget or curl to use this
    return 2
  fi
}

checksum() {
  if [ $# -ne 3 ]; then
    echo "usage: checksum bits <file> <sum file>"
    return 1
  fi
  sum=$(openssl sha1 "-sha${1}" "${2}" | awk '{print $2}')
  if [ "$sum" != "$(cat "${3}")" ]; then
    unset sum
    echo "SHA sum of ${2} does not match the sum in file ${3}" >&2
    return 2
  fi
  unset sum
  return 0
}

install_rust() {
  curl https://sh.rustup.rs -sSf | sh -s -- -y --no-modify-path
}

install_musl_dev() {
  ( 
    cd "$HOME" || exit 1
    git clone git://git.musl-libc.org/musl
    cd musl || exit 1
    ./configure --prefix="$HOME/.local/musl" --exec-prefix="$HOME/.local/"
    make && make install
    cd ..
    rm -rf musl
  )
}

install_helm() {
  release_tag=$(curl -s https://api.github.com/repos/helm/helm/releases |jq -r '[.[] | select(.prerelease == false)][0].tag_name')
  url="https://storage.googleapis.com/kubernetes-helm/helm-$release_tag-$(os)-$(arch).tar.gz"
  sum_url="https://storage.googleapis.com/kubernetes-helm/helm-$release_tag-$(os)-$(arch).tar.gz.sha256"
  tmp_root="$(mktemp -dt install-help-XXXXXX)"
  download "$url" "${tmp_root}/helm.tgz"
  download "$sum_url" "${tmp_root}/helm.tgz.sha256"
  checksum 256 "${tmp_root}/helm.tgz" "${tmp_root}/helm.tgz.sha256" || return 1
  tar xf "${tmp_root}/helm.tgz" -C "${tmp_root}"
  helm="${tmp_root}/$(os)-$(arch)/helm"
  tiller="${tmp_root}/$(os)-$(arch)/tiller"
  mkdir -p "${HOME}/.local/bin"
  mv "$helm" "$tiller" "${HOME}/.local/bin"
  rm -rf "${tmp_root}"
  unset release_tag url sum_url tmp_root helm tiller
}

install_jq() {
  [ "$(os)" != "linux" ] && echo 'linux only - please add others!' >&2 && return 1
  download "https://github.com/stedolan/jq/releases/download/jq-1.6/jq-linux64" "${HOME}/.local/bin/jq"
  chmod 755 "${HOME}/.local/bin/jq"
}

install_neovim() {
  [ "$(os)" != "linux" ] && echo 'linux only - please add others!' >&2 && return 1
  release_tag=$(curl -s https://api.github.com/repos/neovim/neovim/releases |jq -r '[.[] | select(.prerelease == false)][0].tag_name')
  url="https://github.com/neovim/neovim/releases/download/${release_tag}/nvim.appimage"
  download "$url" "${HOME}/.local/bin/nvim"
  chmod 755 "${HOME}/.local/bin/nvim"
  unset release_tag url
}

install_go() {
  arch="$(os)-$(arch)"
  # YOLO: We'll parse the HTML of the download page
  url="$(curl -s https://golang.org/dl/ |grep 'class="download' |grep "$arch" |head -n1 |cut -d\" -f4)"
  mkdir -p "$HOME"/.local
  curl -s "$url" |tar -C "$HOME"/.local -xz
  unset arch url
}

install_kubectl() {
  url="https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/$(os)/$(arch)/kubectl"
  mkdir -p "$HOME"/.local/bin
  download "$url" "$HOME"/.local/bin/kubectl
  chmod 755 "$HOME"/.local/bin/kubectl
  unset url
}

install_kubectl_aws_iam_auth() {
  url="$(curl -s https://api.github.com/repos/kubernetes-sigs/aws-iam-authenticator/releases/latest | \
           grep 'browser_' | \
           cut -d\" -f4 |grep "$(os)"_"$(arch)")"
  download "$url" "$HOME"/.local/bin/aws-iam-authenticator
  chmod 755 "$HOME"/.local/bin/aws-iam-authenticator
  unset url
}

install_aws_vault() {
  output=aws-vault

  if command_exists go; then
    go get github.com/99designs/aws-vault
  else
    # Go get is handy, but we don't actually need 120MB of stuff for the utility
    url="$(curl -s https://api.github.com/repos/99designs/aws-vault/releases \
          |jq -r '.[0].assets[].browser_download_url' \
          |grep "$(os)"-"$(arch)")"
    output_bin="$HOME/.local/bin/$output"
    download "$url" "$output_bin"
    chmod 755 "$output_bin"
    hash $output
  fi
  unset output url output_bin
}

install_firefox () {
  [ "$(os)" != "linux" ] && echo 'linux only - please add others!' >&2 && return 1
  download https://download.mozilla.org/\?product=firefox-latest-ssl\&os=linux64\&lang=en-US /tmp/firefox.tar.bz2
  mkdir -p "$HOME/.local"
  tar -C "$HOME/.local" -xjf /tmp/firefox.tar.bz2
  ln -s "$HOME/.local/firefox/firefox" "$HOME/.local/bin"
  rm /tmp/firefox.tar.bz2
}

install_keepass () {
  [ "$(os)" != "linux" ] && echo 'linux only - please add others!' >&2 && return 1
  repo=keepassxreboot/keepassxc
  release_tag=$(curl -s https://api.github.com/repos/${repo}/releases |jq -r '[.[] | select(.prerelease == false)][0].tag_name')
  mkdir -p "$HOME/.local"
  download "https://github.com/${repo}/releases/download/${release_tag}/KeePassXC-${release_tag}-x86_64.AppImage" "$HOME/.local/bin/KeePassXC-${release_tag}-x86_64.AppImage"
  chmod 755 "$HOME/.local/bin/KeePassXC-${release_tag}-x86_64.AppImage"
  rm "$HOME/.local/bin/keepassxc"
  ln -s "$HOME/.local/bin/KeePassXC-${release_tag}-x86_64.AppImage" "$HOME/.local/bin/keepassxc"
  unset repo release_tag
}

install_linters() {
  [ "$(os)" != "linux" ] && echo 'linux only - please add others!' >&2 && return 1

  mkdir -p "$HOME/.local"
  # sc -linter section
  if ! command_exists shellcheck || [ "$1" = "-f" ]; then
    scversion="stable" # or "v0.4.7", or "latest"
    download "https://storage.googleapis.com/shellcheck/shellcheck-${scversion?}.linux.x86_64.tar.xz" /tmp/shellcheck.tar.xz
    tar -C /tmp -xJf /tmp/shellcheck.tar.xz
    cp "/tmp/shellcheck-${scversion}/shellcheck" "${HOME}"/.local/bin
    rm -rf /tmp/shellcheck.tar.xz "/tmp/shellcheck-${scversion}"
  else
    echo shellcheck already installed. Use -f to force install
  fi

  # cfn-lint
  if ! command_exists cfn-lint || [ "$1" = "-f" ]; then
    pip3 install --user cfn-lint
  else
    echo cfn-lint already installed. Use -f to force install
  fi

  # hadolint
  if ! command_exists hadolint || [ "$1" = "-f" ]; then
    repo=hadolint/hadolint
    release_tag=$(curl -s https://api.github.com/repos/${repo}/releases |jq -r '[.[] | select(.prerelease == false)][0].tag_name')
    download "https://github.com/${repo}/releases/download/${release_tag}/hadolint-Linux-$(arch x86var)" "$HOME/.local/bin/hadolint"
    chmod 755 "$HOME/.local/bin/hadolint"
  else
    echo hadolint already installed. Use -f to force install
  fi

  # golint
  # checkstyle
  # eslint
  # flake8
  if ! command_exists flake8|| [ "$1" = "-f" ]; then
    pip3 install --user flake8
  else
    echo flake8 already installed. Use -f to force install
  fi

  # scalastyle
  # swaglint
  # yamllint
}

########################################################################
# Docker containers
########################################################################
allow_xhost_for_containers() {
  if [ "$1" = "root" ] || alias docker | grep -q podman; then
    # Give display rights to the user if not already enabled
    xhost | grep -q "SI:localuser:root" || \
      xhost +SI:localuser:"root"
  else
    xhost | grep -q "SI:localuser:${USER}" || \
      xhost +SI:localuser:"${USER}"
  fi
}
user_param_for_x() {
  # In rootless mode, we want to run as root, which will map to the right
  # uid outside the container. Otherwise we can't seem to open the display
  if alias docker | grep -q podman; then
    echo "0:0"
  else
    echo "$(id -u "$USER"):$(id -g "$USER")"
  fi
}
generic_x_enabled_run_as() {
  # $1 required - "user" or "root"
  allow_xhost_for_containers "$1"
  # --device /dev/snd \
  if [ "$1" = "root" ]; then
     u=-u; uparam="0:0"
  else # run as user
    if alias docker | grep -q podman; then
       # podman - not sure we want to do anything here due to uid mapping
       u=-u; uparam="0:0"
    else
      # docker
      u=-u; uparam="$(id -u):$(id -g)"
    fi
  fi
  shift
  if [ -f /dev/video0 ]; then
    video=/dev/video0
  else
    video=/dev/null
  fi
  docker run  \
    -v /tmp/.X11-unix:/tmp/.X11-unix \
    -e DISPLAY="unix$DISPLAY" \
    -v /run/dbus/:/run/dbus/ \
    -v /dev/shm:/dev/shm \
    -v /etc/localtime:/etc/localtime:ro \
    --device /dev/dri \
    --device ${video} \
    --group-add "$(getent group audio | cut -d: -f3)" \
    -e PULSE_SERVER="unix:${XDG_RUNTIME_DIR}/pulse/native" \
    -v "${XDG_RUNTIME_DIR}/pulse/native:${XDG_RUNTIME_DIR}/pulse/native" \
    -e LANG \
    $u $uparam \
    --group-add video \
    "$@"

    unset video
}

zoom() {
  allow_xhost_for_containers

  # --device /dev/snd \
  if [ -f /dev/video0 ]; then
    video=/dev/video0
  else
    video=/dev/null
  fi
  docker run  \
    -v /tmp/.X11-unix:/tmp/.X11-unix \
    -e DISPLAY="unix$DISPLAY" \
    -v /run/dbus/:/run/dbus/ \
    -v /dev/shm:/dev/shm \
    --device /dev/dri \
    --device ${video} \
    --group-add "$(getent group audio | cut -d: -f3)" \
    -e PULSE_SERVER="unix:${XDG_RUNTIME_DIR}/pulse/native" \
    -v "${XDG_RUNTIME_DIR}/pulse/native:${XDG_RUNTIME_DIR}/pulse/native" \
    --group-add video \
    -u "$(user_param_for_x)" \
    -d \
    --rm \
    jess/zoom-us

    unset video
}

create_secondary_pa_for_root() {
  # This creates a socket in a 700 directory for pulseaudio. The socket itself
  # has anonymous access, but as it's for audio the threat model is at least
  # somewhat constrained.
  if [ -z "$PULSE_SERVER_SECONDARY_SOCKET" ]; then
    tdir=$(mktemp -d "$XDG_RUNTIME_DIR/pa.XXXXXXX")
    pacmd load-module module-native-protocol-unix auth-anonymous=1 socket="$tdir/pa.socket"
    export PULSE_SERVER_SECONDARY_SOCKET="$tdir/pa.socket"
    unset tdir
  fi
  echo "export PULSE_SERVER_SECONDARY_SOCKET=$PULSE_SERVER_SECONDARY_SOCKET"

}
# We only have a couple config files exposed to host, so we will run this
# as root in the container
workspaces() {
  if alias docker | grep -q podman; then
    # Running as root under docker or podman
    # /Amazon Web Services/Amazon WorkSpaces" \
    vol="/Amazon Web Services/Amazon WorkSpaces"
  else
    # Running as user under docker
    # /home/user/.local/share/Amazon\ Web\ Services/Amazon\ WorkSpaces/
    vol="/home/user/.local/share/Amazon Web Services/Amazon WorkSpaces/"
  fi
  generic_x_enabled_run_as user -d \
    --rm \
    -e TZ="${TZ:-$(cat /etc/timezone)}" \
    -v "${HOME}/.Amazon Web Services/Amazon WorkSpaces:${vol}" \
    docker.lerch.org/linux-workspaces:"${1:-latest}"
  unset vol
}

libreoffice() {
  allow_xhost_for_containers

  docs="$HOME"
  if [ $# -gt 1 ] && [ "$1" = "-h" ]; then
    docs="${2}"
    shift; shift
  fi

  docker run --rm -d \
          -v /etc/localtime:/etc/localtime:ro \
          -v /etc/passwd:/etc/passwd:ro \
          -v /tmp/.X11-unix:/tmp/.X11-unix \
          -e DISPLAY=unix"$DISPLAY" \
          -v "$docs":"$docs" \
          -w "$PWD" \
          -e HOME="$docs" \
          -u "$(user_param_for_x)" \
          -e GDK_SCALE \
          -e GDK_DPI_SCALE \
          elerch/libreoffice "$@"
  unset docs
}

chrome() {
  ! [ -d "$HOME/.config/chrome" ] && mkdir -p "$HOME/.config/chrome"
  # anonymous by default. Other branch is "loggedin"
  git -C "$HOME/.config/chrome" checkout -f "${1:-anonymous}" > /dev/null
  git -C "$HOME/.config/chrome" clean -df >/dev/null

  allow_xhost_for_containers
  user="$(user_param_for_x)"
  resource_limits=""
  if [ "$user" != "0:0" ]; then
    # running in rootless mode
    # shellcheck disable=2086
    resource_limits="--cpuset-cpus 2 --memory ${2:-"2048mb"}"
  else
    flags="--no-sandbox"
  fi
  # We're giving 2GB by default. I tried lower values, but
  # some of the normal Google properties I use suck memory
  # like a pig. I'm looking at you, Google meetings...
  # shellcheck disable=2046
  # shellcheck disable=2116 # not sure why this works like that
  docker run -it \
    --net host \
    $(echo "$resource_limits") \
    -v /tmp/.X11-unix:/tmp/.X11-unix \
    -e DISPLAY=unix"$DISPLAY" \
    -v "$HOME"/Downloads:/home/chrome/Downloads \
    -v "$HOME"/.config/chrome/:/data \
    -v /run/dbus/:/run/dbus/ \
    -v /dev/shm:/dev/shm \
    --security-opt seccomp="$HOME"/chrome.json \
    --device /dev/snd \
    --device /dev/dri \
    --device /dev/video0 \
    --group-add "$(getent group audio | cut -d: -f3)" \
    -e PULSE_SERVER=unix:"${XDG_RUNTIME_DIR}"/pulse/native \
    -v "${XDG_RUNTIME_DIR}"/pulse/native:"${XDG_RUNTIME_DIR}"/pulse/native \
    --group-add video \
    -u "$user" \
    --name chrome \
    --rm \
    jess/chrome $flags
}

docker_search_tags() {
  [ ${#} -ne 1 ] && echo "docker_search_tags <image>" >&2 && return 1
  i=0

  tags="start"
  while [ "$tags" != "" ]
  do
     i=$((i+1))
     tags=$(curl https://registry.hub.docker.com/v2/repositories/library/"${1}"/tags/\?page=$i 2>/dev/null|jq -r '."results"[]["name"]')
     echo "$tags"
  done
  unset tags
}

screen_geometry() {
  percentage=80 # 80% (TODO: allow this to be passed on cmdline

  currentdisplays=$(xrandr |grep -e ' connected\|\*')
  # Value should look like this:
  #
  # eDP-1 connected 2560x1600+5120+0 (normal left inverted right x axis y axis) 286mm x 179mm
  #    2560x1600     59.97*+
  # DP-1 connected primary 2560x1440+2560+0 (normal left inverted right x axis y axis) 597mm x 336mm
  #    2560x1440     59.95*+
  # DP-2 connected 2560x1440+0+0 (normal left inverted right x axis y axis) 597mm x 336mm
  #    2560x1440     59.95*+
  primarydisplay=$(echo "$currentdisplays"|grep primary|awk '{print $1}')
  selectedisplay=$primarydisplay
  if [ -n "$1" ]; then
    if [ "$1" != "primary" ]; then
      selectedisplay="$1"
    fi
  else
    # User hasn't selected anything. Read fron stdin
    echo "Current displays:"
    echo "$currentdisplays"
    printf "Choose the display you'd like (%s): " "$selectedisplay"
    read -r selectedisplay
    [ -z "$selectedisplay" ] && selectedisplay=$primarydisplay
  fi
  if ! echo "$currentdisplays"|grep -q -e "^$selectedisplay"; then
    echo "Could not find display $selectedisplay" >&2
    return 1
  fi
  # Grab geometry for selected display
  geometry=$(echo "$currentdisplays"|grep -A 1 -e "^$selectedisplay"|tail -1|awk '{print $1}')
  # Should look like this: 2560x1600. I'm sure we can do this with a read and IFS thing,
  # but I won't bother here. Slower but clearer...
  width=$(echo "$geometry"|cut -dx -f1)
  height=$(echo "$geometry"|cut -dx -f2)
  targetwidth=$(echo $((width * percentage / 100))|cut -d. -f1)
  targetheight=$(echo $((height * percentage / 100))|cut -d. -f1)
  echo "${targetwidth}x${targetheight}"
}

focused_screen() {
  # ok - this is a huge leap. xwininfo will give (at least on my machine)
  # window manager information that says "displayed on desktop n". I suspect
  # this is specific to i3wm/not portable/etc.
  #
  # Further, I'm going to (probably incorrectly) assume that the 0-based numbering
  # corresponds to the ordering of the connected output that returns from
  # xrandr with no options. I don't see a tool for otherwise connecting "desktop number"
  # to "output", though there's probably something in i3wm that I'm unaware of
  # desktopnumber=$(xwininfo -wm -id "$(xdpyinfo |grep focus |awk '{print $3}'|cut -d, -f1)" \
  #                 |grep Displayed \
  #                 |awk '{print $4}')


  # new plan, party people. Since we assume we're running i3
  # (DESKTOP_STARTUP_ID should start with "i3"), we can use i3-msg -t get_tree
  # to find the only window with "focused": true property, and grab the output
  if ! env|grep -q 'DESKTOP_STARTUP_ID=i3'; then
    echo Currently this function supports i3wm only >&2
    exit 1
  fi
  i3-msg -t get_tree |jq "
def flat:
  { output: (if (.focused == true) then (.output) else (.nodes[] |flat) end)};

.nodes[] | flat" | grep -v -e '[{}]'|awk '{print $2}' |cut -d\" -f2
}

rdesktop () {
  allow_xhost_for_containers
  geometry=""
  if [ $# -eq 1 ]; then
    # establish geometry based on 80% of current screen
    geometry="-g $(screen_geometry "$(focused_screen)")"
  fi
  echo "Container attached to TTY. Ctrl-P + Ctrl-Q to detach"
  # would be nice to name the container after the host connection
  # shellcheck disable=SC2086
  docker run -it --rm -e DISPLAY=unix"$DISPLAY" \
    -v /tmp/.X11-unix:/tmp/.X11-unix \
    -v "$HOME":"$HOME" \
    -u "$(user_param_for_x)" \
    jess/rdesktop -u "${USER}" $geometry "$@"
  unset geometry
}

my_ipv4 () {
  curl -s -4 ifconfig.co
}

authorize_security_group_ingress () {
  [ ${#} -ne 3 ] && echo "authorize_security_group_ingress <groupname> <protocol> <port>" >&2 && return 1
  echo "Revoking any previously authorized ingress for this host"
  revoke_security_group_ingress "$1" "$2" "$3"
  echo "Adding authorization for host"
  aws ec2 authorize-security-group-ingress --group-name "$1" --ip-permissions \
    "IpProtocol=$2,FromPort=$3,ToPort=$3,IpRanges=[{CidrIp=$(curl -s -4 ifconfig.co)/32,Description=Host:$HOST}]"
}

revoke_security_group_ingress () {
  [ ${#} -ne 3 ] && echo "revoke_security_group_ingress <groupname> <protocol> <port>" >&2 && return 1
  # looking for security group description in the format Host:$HOST
  ip="$(aws ec2 describe-security-groups --group-name "$1" | \
           jq -r ".SecurityGroups[0].IpPermissions[0].IpRanges[] | select(.Description==\"Host:$HOST\") | .CidrIp")"
  [ -z "$ip" ] && echo "Ip not found for host on SG $1" && return 0
  aws ec2 revoke-security-group-ingress --group-name "$1" --protocol "$2" --port "$3" --cidr "$ip"
  unset ip
}

install_language_servers () {
  # Javascript is a real PITA
  # using nvm, npm install -g javascript-typescript-langserver
  # Rust
  command_exists rustup && \
    echo 'installing Rust rls' && \
    rustup update && \
    rustup component add rls rust-analysis rust-src

  # Python
  command_exists pip && \
    echo 'installing python-language-server (pyls)' && \
    pip install --user python-language-server

  # Go
  command_exists go && \
    echo 'installing go-language-server' && \
    go get -u github.com/saibing/bingo
}

gpgedit () {
  tmpfile="$(mktemp)"
  gpg -d "$1" >> "$tmpfile"
  "$EDITOR" "$tmpfile"
  gpg -e -s --default-recipient-self < "$tmpfile" > "$1"
  rm "$tmpfile"
  unset tmpfile
}

get_secret () {
  if [ $# -eq 0 ]; then
    echo "usage: get_secret <secret name> [-d]" >&2
    echo "       -d evaluate secret data as environment variable assignments - put in docker arg format" >&2
    echo '' >&2
    echo 'view/edit secrets with gpgedit "${HOME}/.secrets"' >&2
    return 1
  fi
  if ! [ -r "${HOME}/.secrets" ]; then
    echo "# name|secretdata" | gpg -e -s --default-recipient-self > "${HOME}/.secrets"
  fi
  # Assumes file is organized so it's secretname|data...
  secret="$(gpg -d "${HOME}/.secrets" 2>/dev/null | grep -e "^${1}|" | cut -d\| -f 2)"
  if [ "$2" = "-d" ]; then
    for var in $(echo "$secret"); do printf " -e %s" "$var"; done && printf '\n'
  else
    echo "$secret"
  fi
  unset secret
}
set_env_from_aws_secret () {
  # Need a subshell so we don't whack environment variables
  (
    secretid="${1:-S3ReadCreds}"
    key=''
    for env in $(aws secretsmanager get-secret-value --secret-id "$secretid" \
                     --query 'SecretString' \
                     --output text |jq . |grep -v -e '^[\{\}]'); do
      if [ -z "$key" ]; then
        key="$(echo "$env"|cut -d\" -f2)"
      else
        value="$(echo "$env"|cut -d\" -f2)"
        eval "export $key=$value"
        key=''
      fi
    done
    unset AWS_SESSION_TOKEN AWS_SECURITY_TOKEN
    if [ -n "$AWS_VAULT" ]; then
      export AWS_VAULT="${AWS_VAULT}($secretid)"
    fi
    unset key value secretid
    eval "$SHELL"
  )
}

aws_vault_docker_variables () {
  echo "-e AWS_ACCESS_KEY_ID -e AWS_SECRET_ACCESS_KEY -e AWS_SESSION_TOKEN -e AWS_SECURITY_TOKEN -e AWS_REGION -e AWS_DEFAULT_REGION"
}
